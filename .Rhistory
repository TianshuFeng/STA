groups_ind = NULL,
color_code = NULL,
color_mix = FALSE,
save_network = TRUE) {
require(visNetwork)
require(RColorBrewer)
# Remove nodes without samples
obj_mapper = STA:::null_remover(obj_mapper)
MapperNodes <- STA:::mapperVertices(obj_mapper, 1)
MapperLinks <- STA:::mapperEdges(obj_mapper)
if (color_filter) {
if (is.null(color_fun)) {
stop("color_fun not provided")
}
if (is.null(filter)) {
warning("filter not provided, repalced by 1.")
filter <- rep(1, max(unlist(obj_mapper$points_in_vertex)))
}
dir.create(file.path(folder), showWarnings = FALSE)
avg_filter <- c()
for (i in obj_mapper$points_in_vertex) {
avg_filter <- c(avg_filter, mean(filter[i], na.rm = TRUE))
}
# Standardize to (0, 1)
avg_filter <- (avg_filter - min(avg_filter))/(max(avg_filter) - min(avg_filter))
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
color = color_fun(avg_filter)
)
} else if (is.null(color_code)) {
if (is.null(color_fun)) {
stop("Either color_code or color_fun not provided")
}
if (is.null(groups_ind)) {
stop("Samples' groups_ind not provided")
}
# Use dominant group
if (!color_mix) {
dom_grp <- c()
for (i in obj_mapper$points_in_vertex) {
dom_grp <-
c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
}
dom_grp <- as.numeric(as.factor(dom_grp)) - 1
if(max(dom_grp) == 0) {
dom_grp <- dom_grp + 1
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
color = color_fun(dom_grp / max(dom_grp))
)
} else if (color_mix) {
sample_color <- as.numeric(as.factor(groups_ind)) - 1
if(max(sample_color) == 0) {
sample_color <- sample_color + 1
}
sample_color <- color_fun(sample_color/max(sample_color))
avg_color <- c()
for (i in obj_mapper$points_in_vertex) {
avg_color <- c(avg_color, color_mixer(sample_color[i], na.rm = TRUE))
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
color = avg_color
)
}
} else if (check_color_code(color_code)) {
if (is.null(groups_ind)) {
stop("Samples' groups_ind not provided")
}
# Use provided color code
if(!color_mix) {
dom_grp <- c()
for (i in obj_mapper$points_in_vertex) {
dom_grp <-
c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
group = dom_grp,
color = color_map(dom_grp, color_code = color_code)
)
} else if (color_mix) {
sample_color <- color_map(groups_ind, color_code = color_code)
avg_color <- c()
dom_grp <- c()
for (i in obj_mapper$points_in_vertex) {
avg_color <- c(avg_color, color_mixer(sample_color[i], na.rm = TRUE))
dom_grp <-
c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
group = dom_grp,
color = avg_color
)
} else {
stop("Invalid color_mix. Should be Boolean.")
}
} else {
stop("Invalid color code")
}
edges <-
data.frame(from = MapperLinks$Linksource + 1,
to = MapperLinks$Linktarget + 1,
width = MapperLinks$Linkvalue/max(MapperLinks$Linkvalue) * 20)
net_file <- visNetwork(nodes, edges, width = "100%", height = "700px") %>%
visInteraction(tooltipDelay = 500,
selectConnectedEdges = FALSE) %>%
visOptions(highlightNearest = list(
enabled = TRUE,
degree = 2,
hover = T) )
if(save_network) {
print(net_file)
net_file %>% visSave(file = network_name, background = "white")
save_logic = file.rename(from = network_name, to = file.path(folder, network_name))
if (save_logic) {
cat("The generated HTML file can be found in:\n",
file.path(folder, network_name),
"\n")
} else {
warning("Cannot save file in the target folder,
please check the working directory.")
}
} else {
return(net_file)
}
}
runApp('inst/STA-app')
color_map_Spectral
?brewer.pal
write.csv(tp_data, file = "/Volumes/GoogleDrive/My Drive/Mayo_intern files/Projects/Mapper_Visualization/Package/SemiMapper/inst/STA-app/chick_foot.csv")
runApp('inst/STA-app')
runApp()
runApp('inst/STA-app')
tp_data["Group"]
tp_data["Group"][3]
tp_data["Group"][3,]
runApp('inst/STA-app')
tp_data["Group"][3:10,]
runApp('inst/STA-app')
shiny::runApp(system.file("shiny", package = "visNetwork"))
shiny::runApp(system.file("shiny", package = "visNetwork"))
runApp('inst/STA-app')
runApp('inst/STA-app')
?colorRampPalette
?colorRamp
colorRamp(brewer.pal(11, "Spectral"))(1:10)
colorRamp(brewer.pal(11, "Spectral"))(1:10/10)
colorRampPalette(brewer.pal(11, "Spectral"))(1:10/10)
colorRampPalette(brewer.pal(11, "Spectral"))(100)
?brewer.pal
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runExample("06_tabsets")
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp('inst/STA-app')
runApp()
runApp('inst/STA-app')
tp_data['group']
tp_data['Group']
runApp('inst/STA-app')
a = read.csv("/Volumes/GoogleDrive/My Drive/Mayo_intern files/Projects/Mapper_Visualization/Package/SemiMapper/inst/STA-app/example_descript.csv")
a
sapply(a, is.factor)
colnames(description())[sapply(a, is.factor)]
colnames(a)[sapply(a, is.factor)]
a['group']
runApp('inst/STA-app')
runApp()
runApp('inst/STA-app')
#' Remove NULL nodes in the graph
#'
#' @param obj_mapper The Mapper object
#'
#' @return A Mapper object
#' @keywords internal
#'
null_remover <- function(obj_mapper) {
null_idx <- which(sapply(obj_mapper$points_in_vertex, is.null), arr.ind = TRUE)
if (length(null_idx) > 0) {
obj_mapper$adjacency <- obj_mapper$adjacency[-null_idx, -null_idx]
obj_mapper$points_in_vertex <- obj_mapper$points_in_vertex[-null_idx]
obj_mapper$num_vertices <- length(obj_mapper$points_in_vertex)
obj_mapper$level_of_vertex <- obj_mapper$level_of_vertex[-null_idx]
}
return(obj_mapper)
}
#' Spectral color map function
#'
#' \code{color_map_Spectral} maps numeric values between 0 and 1 to hex codes
#'
#' @param x A numeric vector whose entries are between 0 and 1.
#'
#' @return A vector of hex codes.
#' @export
#'
#' @examples
#' color_map_Spectral((1:5)/5)
#'
color_map_Spectral <- function(x, name = "Spectral") {
require(RColorBrewer)
color_temp <- colorRamp(brewer.pal(11, name))(x)
color_hex <- rgb(color_temp[, 1], color_temp[, 2], color_temp[, 3],
maxColorValue = 255)
return(color_hex)
}
#' Color mixer
#'
#' @param colors vector of Hex colors
#' @param weight vector of weight of each color in calculating the average
#'
#' @return A char of Hex color code.
#' @export
#' @keywords internal
#'
#' @examples
color_mixer <- function(col_vec, weight = NULL, na.rm = TRUE) {
rgb_mat <- col2rgb(col_vec)
if (is.null(weight)) {
weight <- rep(1, length(col_vec))
} else if (length(weight) != length(col_vec)) {
stop("The length of weight is not equal")
}
if(na.rm) {
col_vec <- na.omit(col_vec)
}
weight <- weight/sum(weight)
avg_col <- rgb_mat %*% weight
avg_col_hex <- rgb(red = avg_col[1],
green = avg_col[2],
blue = avg_col[3],
maxColorValue = 255)
return(avg_col_hex)
}
savepdf <- function(file, folder = "", width = 10, height = 10) {
dir.create(file.path(folder, "figures"), showWarnings = FALSE)
fname <- paste(folder, "/figures/", file, ".png", sep = "")
png(fname)
par(mgp = c(0, 0, 0), tcl = -0.4, mar = c(0, 0, 0, 0), oma = c(0, 0,
0, 0), bg = NA)
}
#' mapperVertices function
#'
#' The input to this function is a TDAmapper class object and the output
#' is a data frame of vertices that can be used as input to the networkD3
#' plot utility.
#'
#' @param m An object of class TDAmapper that is the output of the mapper
#' function.
#'
#' @return A data frame describing the vertices in the graph of the mapper
#' output and the point labels that will be displayed when the mouse
#' hovers over a vertex in the graph.
#'
#' @author Paul Pearson, \email{pearsonp@@hope.edu}
#' @references \url{https://github.com/paultpearson/TDAmapper}
#' @seealso \code{\link{mapperEdges}}
#' @keywords mapperVertices
#'
#' @keywords internal
#'
mapperVertices <- function(m, pt_labels) {
# Hovering over vertices gives the point labels: convert the list of
# vectors of point indices to a list of vectors of labels
labels_in_vertex <- lapply(m$points_in_vertex, FUN = function(v) {
pt_labels[v]
})
nodename <- sapply(sapply(labels_in_vertex, as.character), paste0,
collapse = ", ")
nodename <- paste0("V", 1:m$num_vertices, ": ", nodename)
# Hovering over vertices gives the point indices: list the points in
# each vertex nodename <- sapply( sapply(m$points_in_vertex,
# as.character), paste0, collapse=', ') concatenate the vertex number
# with the labels for the points in each vertex nodename <- paste0('V',
# 1:m$num_vertices, ': ', nodename )
nodegroup <- m$level_of_vertex
nodesize <- sapply(m$points_in_vertex, length)
return(data.frame(Nodename = nodename, Nodegroup = nodegroup, Nodesize = nodesize))
}
#' mapperEdges function
#'
#' The input to this function is a TDAmapper class object and the output
#' is a data frame of edges that can be used as input to the networkD3
#' plot utility.
#'
#' @param m An object of class TDAmapper that is the output of the mapper function.
#'
#' @return A data frame describing the edges in the graph of the mapper output.
#'
#' @author Paul Pearson, \email{pearsonp@@hope.edu}
#' @references \url{https://github.com/paultpearson/TDAmapper}
#' @seealso \code{\link{mapperVertices}}
#' @keywords mapperEdges
#'
#' @keywords internal
#'
mapperEdges <- function(m) {
linksource <- c()
linktarget <- c()
linkvalue <- c()
k <- 1
for (i in 2:m$num_vertices) {
for (j in 1:(i - 1)) {
if (m$adjacency[i, j] == 1) {
linksource[k] <- i - 1
linktarget[k] <- j - 1
# Calculate the percentage of overlaped samples
node1 <- m$points_in_vertex[[i]]
node2 <- m$points_in_vertex[[j]]
inter <- intersect(node1, node2)
linkvalue[k] <- length(inter)/min(length(node1), length(node2))
k <- k + 1
}
}
}
return(data.frame(Linksource = linksource, Linktarget = linktarget,
Linkvalue = linkvalue))
}
num_obs_network <- function(obj_mapper) {
nobs <- sapply(tp_data_mapper$points_in_vertex, max)
return(max(nobs))
}
num_obs_network <- function(obj_mapper) {
nobs <- sapply(obj_mapper$points_in_vertex, max)
return(max(nobs))
}
runApp('inst/STA-app')
#' @export
#'
#' @examples
#' tp_data = chicken_generator(1)
#' tp_data_mapper = mapper.kmeans(dat = tp_data[,2:4],
#'                                filter_values = tp_data$Y,
#'                                num_intervals = 10,
#'                                percent_overlap = 70)
#' simple_visNet(tp_data_mapper, filter = tp_data$Y)
#'
simple_visNet <-
function(obj_mapper,
filter = NULL,
folder = getwd(),
color_fun = color_map_Spectral,
network_name = "network.html",
color_filter = TRUE,
groups_ind = NULL,
color_code = NULL,
color_mix = FALSE,
save_network = TRUE) {
require(visNetwork)
require(RColorBrewer)
# Remove nodes without samples
obj_mapper = STA:::null_remover(obj_mapper)
MapperNodes <- STA:::mapperVertices(obj_mapper, 1)
MapperLinks <- STA:::mapperEdges(obj_mapper)
if (color_filter) {
if (is.null(color_fun)) {
stop("color_fun not provided")
}
if (is.null(filter)) {
warning("filter not provided, repalced by 1.")
filter <- rep(1, max(unlist(obj_mapper$points_in_vertex)))
}
dir.create(file.path(folder), showWarnings = FALSE)
avg_filter <- c()
for (i in obj_mapper$points_in_vertex) {
avg_filter <- c(avg_filter, mean(filter[i], na.rm = TRUE))
}
# Standardize to (0, 1)
avg_filter <- (avg_filter - min(avg_filter))/(max(avg_filter) - min(avg_filter))
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
color = color_fun(avg_filter)
)
} else if (is.null(color_code)) {
if (is.null(color_fun)) {
stop("Either color_code or color_fun not provided")
}
if (is.null(groups_ind)) {
stop("Samples' groups_ind not provided")
}
# Use dominant group
if (!color_mix) {
dom_grp <- c()
for (i in obj_mapper$points_in_vertex) {
dom_grp <-
c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
}
dom_grp <- as.numeric(as.factor(dom_grp)) - 1
if(max(dom_grp) == 0) {
dom_grp <- dom_grp + 1
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
color = color_fun(dom_grp / max(dom_grp))
)
} else if (color_mix) {
sample_color <- as.numeric(as.factor(groups_ind)) - 1
if(max(sample_color) == 0) {
sample_color <- sample_color + 1
}
sample_color <- color_fun(sample_color/max(sample_color))
avg_color <- c()
for (i in obj_mapper$points_in_vertex) {
avg_color <- c(avg_color, color_mixer(sample_color[i], na.rm = TRUE))
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
color = avg_color
)
}
} else if (check_color_code(color_code)) {
if (is.null(groups_ind)) {
stop("Samples' groups_ind not provided")
}
# Use provided color code
if(!color_mix) {
dom_grp <- c()
for (i in obj_mapper$points_in_vertex) {
dom_grp <-
c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
group = dom_grp,
color = color_map(dom_grp, color_code = color_code)
)
} else if (color_mix) {
sample_color <- color_map(groups_ind, color_code = color_code)
avg_color <- c()
dom_grp <- c()
for (i in obj_mapper$points_in_vertex) {
avg_color <- c(avg_color, color_mixer(sample_color[i], na.rm = TRUE))
dom_grp <-
c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
}
nodes <-
data.frame(
id = 1:nrow(MapperNodes),
value = MapperNodes$Nodesize,
group = dom_grp,
color = avg_color
)
} else {
stop("Invalid color_mix. Should be Boolean.")
}
} else {
stop("Invalid color code")
}
edges <-
data.frame(from = MapperLinks$Linksource + 1,
to = MapperLinks$Linktarget + 1,
width = MapperLinks$Linkvalue/max(MapperLinks$Linkvalue) * 20)
net_file <- visNetwork(nodes, edges, width = "100%", height = "700px") %>%
visInteraction(tooltipDelay = 500,
selectConnectedEdges = FALSE) %>%
visOptions(highlightNearest = list(
enabled = TRUE,
degree = 2,
hover = T) )
if(save_network) {
print(net_file)
net_file %>% visSave(file = network_name, background = "white")
save_logic = file.rename(from = network_name, to = file.path(folder, network_name))
if (save_logic) {
cat("The generated HTML file can be found in:\n",
file.path(folder, network_name),
"\n")
} else {
warning("Cannot save file in the target folder,
please check the working directory.")
}
} else {
return(net_file)
}
}
runApp('inst/STA-app')
runApp('inst/STA-app')
