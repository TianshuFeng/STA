#' Spectral color map function
#'
#' \code{color_map_Spectral} maps numeric values between 0 and 1 to hex codes
#'
#' @param x A numeric vector whose entries are between 0 and 1.
#'
#' @return A vector of hex codes.
#' @export
#'
#' @examples
#' color_map_Spectral((1:5)/5)
#'
color_map_Spectral = function(x){
  color_temp = colorRamp(brewer.pal(11,"Spectral"))(x)
  color_hex = rgb(color_temp[,1], color_temp[,2], color_temp[,3], maxColorValue = 255)
  return(color_hex)
}


#' Simple graphs generation
#'
#' \code{simple_visNet} generates graphs from the provided Mapper object without
#' tooltips.
#'
#' \code{simple_visNet} generates graphs from the provided Mapper object without
#' tooltips. The colors of nodes can be more flexibly defined than in
#' \code{\link{network_visualization}} which is suitable for simulation and
#' tests.
#'
#' Users can assign colors to nodes with three different approaches.If
#' \code{color_filter=TRUE}, the colors of nodes are determined by the average
#' filter values of samples, and \code{color_fun} will map numeric values to hex
#' color codes. If \code{color_filter=FALSE} and \code{color_code=NULL}, the
#' colors of nodes are determined by the dominated group of samples, and colors
#' are automatically generated by \code{color_fun}. If \code{color_filter=FALSE}
#' and \code{color_code!=NULL}, the colors of nodes are determined by the
#' dominated group of samples, and colors are from \code{color_code}. Note than
#' the color method should be specified by the users by providing the function
#' with necessary arguments.
#'
#'
#' @inheritParams network_visualization
#' @param filter A vector of filter values from filter functions
#' @param color_fun The color function that transforms numbers to hex codes.
#' @param network_name File name of the html network file.
#' @param color_filter  A logical object. \code{TRUE} if colors of nodes are to
#'   be determined by the average filter values of samples.
#' @param color_code A color code dataframe.
#'
#' @return An HTML file saved under the location
#'   given in \code{folder}. The HTML file contains the interactive graph
#'   generated based on the Mapper object.
#' @export
#'
#' @examples
#' library(TDAmapper)
#' tp_data = chicken_generator(1)


simple_visNet = function(obj_mapper, filter=NULL, folder, color_fun = color_map_Spectral,
                         network_name = "network.html", color_filter = TRUE,
                         groups_ind = NULL, color_code = NULL){

  MapperNodes <- mapperVertices(obj_mapper, 1)
  MapperLinks <- mapperEdges(obj_mapper)

  if(color_filter) {

    if(is.null(color_fun)) {
      stop("color_fun not provided")
    }

    if(is.null(filter)) {
      warning("filter not provided, repalced by 1.")
      filter = rep(1, max(unlist(obj_mapper$points_in_vertex)))
    }

    avg_filter = c()
    for(i in obj_mapper$points_in_vertex){
      avg_filter = c(avg_filter, mean(filter[i], na.rm = TRUE))
    }

    nodes <- data.frame(id = 1:nrow(MapperNodes), #label = MapperNodes$Nodename,
                        value = MapperNodes$Nodesize,
                        color = color_fun(avg_filter))
  } else if(is.null(color_code)){

    if(is.null(color_fun)) {
      stop("Either color_code or color_fun not provided")
    }

    if(is.null(groups_ind)) {
      stop("Samples' groups_ind not provided")
    }

    # Use dominant group
    dom_grp = c()
    for(i in obj_mapper$points_in_vertex){
      dom_grp = c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1] )
    }
    dom_grp = as.numeric(dom_grp)

    nodes <- data.frame(id = 1:nrow(MapperNodes), #label = MapperNodes$Nodename,
                        value = MapperNodes$Nodesize,
                        color = color_fun(dom_grp/max(groups_ind)))

  } else if(check_color_code(color_code)) {

    if(is.null(groups_ind)) {
      stop("Samples' groups_ind not provided")
    }

    # Use provided color code
    dom_grp = c()
    for(i in obj_mapper$points_in_vertex){
      dom_grp = c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1] )
    }

    nodes <- data.frame(id = 1:nrow(MapperNodes), #label = MapperNodes$Nodename,
                        value = MapperNodes$Nodesize,
                        group = dom_grp,
                        color = color_map(dom_grp,
                                          color_code = color_code))
  } else {
    stop("Invalid color code")
  }

  edges <- data.frame(from = MapperLinks$Linksource+1, to = MapperLinks$Linktarget+1)

  visNetwork(nodes, edges, width = "100%", height = "700px") %>%
    visInteraction(tooltipDelay = 500, selectConnectedEdges = FALSE) %>%
    visOptions(highlightNearest = list(enabled =TRUE, degree = 2, hover = T)) %>%
    visSave(file = network_name, background = "white")

  file.rename(from = network_name, to = file.path(folder, network_name))
}


#' Chicken foot simulation data generator
#'
#' \code{chicken_generator} generates chicken foot simulation data.
#'
#' \code{chicken_generator} generates chicken foot simulation data with 450 data
#' points in total. It consists of three toes and one shank. Each of the toes
#' contains 105 data points and the shank contains 135 data points.
#'
#' @param seed A scaler determining the seed to be used.
#'
#' @return A dataframe of the simulated data. The first three columns are the
#'   coordinates of data points, and the forth column denote the groups of the
#'   points.
#' @export
#'
#' @examples
#' chicken_generator(1)
#'
chicken_generator = function(seed = 1) {
  library(MASS)
  set.seed(seed)

  x_1 = 0:20
  y_1 = 2*x_1
  d1 = cbind(1, x_1, y_1)

  x_2 = -x_1
  y_2 = y_1
  d2 = cbind(2, x_2, y_2)

  x_3 = 0
  y_3 = 0:(-20)
  d3 = cbind(4, x_3, y_3)

  x_4 = 0
  y_4 = 0:20*2
  d4 = cbind(3, x_4, y_4)

  d = rbind(d1, d2, d3, d4)

  d = cbind(d, 0)

  dd = NULL
  for(i in 1:nrow(d)) {
    tmp = mvrnorm(n=5, mu = as.vector(d[i,2:4]), Sigma = 0.7*diag(3))
    tmp = cbind(d[i,1], tmp)
    dd = rbind(dd, (tmp))
  }

  dd = rbind(dd, cbind(4, mvrnorm(n=30, mu = c(0,-0.5,0), Sigma = diag(c(16,8,1))) ))

  dd = as.data.frame(dd)
  colnames(dd) = c("Group","X", "Y", "Z")

  dd$Y = dd$Y - min(dd$Y)
  dd$X = dd$X - min(dd$X)
  dd$Z = dd$Z - min(dd$Z)

  dd$X = dd$X/max(dd$X + 0.01)
  dd$Y = dd$Y/max(dd$Y + 0.01)
  dd$Z = dd$Z/max(dd$Z + 0.01)/5

  return(dd)
}

