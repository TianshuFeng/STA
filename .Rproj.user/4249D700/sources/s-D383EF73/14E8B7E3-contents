---
title: "Semi-supervised Mapper"
author: ""
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This package aims to provide an easy and flexible way to explore the visualization of data based on Mapper, a topological data analysis method, It provides users with extensive tools to customize the visualization, optimally select filter functions and evaluate the results from Mapper.

To install the latest version of this R package directly from github:
```
install.package("devtools")
devtools::install_github(TianshuFeng/SemiMapper)
```

# Example 1: Simple graph generation with SemiMapper.

## Start with the simulation data

This package provides a function `chicken_generator` to generate simulation data which is similar to a chicken foot. We will use it to demostrate the tools of this package.

We start by applying Mapper directly to the simulated data with function `mapper.kmeans` and generate a graph with the basic visualization function `simple_visNet`.

```{r eval=FALSE}
library(SemiMapper)
simu_data <-  chicken_generator(seed = 1)
simu_data_mapper <- mapper.kmeans(dat = simu_data[,2:4],
                               filter_values = simu_data$Y,
                               num_intervals = 10,
                               percent_overlap = 70)
simple_visNet(simu_data_mapper, filter = simu_data$Y, color_filter = TRUE)
```
In `chicken_generator`, the argument `seed` determines the seed to be used in data generation. The first column represent the groups of samples, and the last three columns are the coordinates of samples. 

We apply Mapper to the simulated data with function `mapper.kmeans` modified from function `mapper` in package `TDAmapper`. In `mapper.kmeans`, `dat` is the input data, `filter_values` is the vector of filter. Here we simply use the Y axis as the filter. `num_intervals` and `percent_overlap` are the number of intervals and the percentage of intervals overlapped, respectively, which decides how `simu_data$Y` is convered. 

`simple_visNet` function visualize the graph from `mapper.kmeans`. It is capable of flexibly assigning colors to nodes in the graph. In this example, we set `color_filter = TRUE` and `filter = simu_data$Y`, and the colors of nodes are determined by the average values of filters of samples in the nodes.

## Play with colors

We can also assign colors with the dominated group under each node with 
```{r eval=FALSE}
simple_visNet(simu_data_mapper, color_filter = FALSE, groups_ind = simu_data$Group)
```
The colors will be determined by built-in function `color_map_Spectral()` based on the dominated groups. Users can also define their own color function and pass it to argument `color_fun`. The color function should be able to accept numeric vectors and output hex color codes.

Alternatively, we can specify the colors of groups. This package provides several tools to help the users define colors for the groups. `auto_set_colorcode` is able to automatically generate color codes based on given palette. `read_color_code` can read color codes from local files and turn them into appropriate format, and `check_color_code` checks the validity of provided color code data frame. 

We demostrate these tools with the following codes:
```{r eval=FALSE}
simu_color <- auto_set_colorcode(simu_data$Group, palette = "Set1")
check_color_code(simu_color)
simple_visNet(simu_data_mapper, color_filter = FALSE, 
              groups_ind = simu_data$Group,color_code = simu_color)
```

A full list of supported palettes can be found with function `display.brewer.all()` in package `RColorBrewer`.

# Example 2: Adding details of nodes to graphs.
## Using default summaries

Extra summaries of nodes can be added to the graph with the function `network_visualization`, which is more powerful in providing additional summaries of nodes than `simple_visNet`.

The usage of `network_visualization` is similar to `simple_visNet`:
```{r eval = FALSE}
tp_data <- chicken_generator(1)
ff <- filter_coordinate(tp_data[,-1], 2)
tp_data_mapper <- mapper.kmeans(dat = tp_data[,2:4],
                               filter_values = ff,
                               num_intervals = 10,
                               percent_overlap = 70)
network_visualization(tp_data_mapper, groups_ind = tp_data$Group, dat = tp_data[,2:4],
                      folder = "Exp_network")
```
One difference between `network_visualization` and `simple_visNet` is that in `network_visualization`, the groups of samples must be defined by users, because the percentages of groups of samples in each node is part of the basic summary information. Nevertheless, `network_visualization` can automatically assign colors to groups, and color tools introduced in "Play with colors" can still be used to help the users to define their own colors for different groups of samples.

The generated graphs from `network_visualization` and `simple_visnet` are also different. Besides the graph itself, the graph from `network_visualization` contains summaries of nodes which will show up when hovering the mouse cursor on a node. Basic summary information includes the number of samples in the node, the dominated group of the node, the percentages of groups of samples in the node and a pie plot depicting the percentages of groups.

## Adding customized summaries

Users can also add customized summaries of nodes to the graph generated by `network_visualization`, which allows the users to evaluate the graph based on the unique features of the data. This is achieved by passing JavaScript organizing the summaries to `add_analysis_java` of `network_visualization` 
```{r eval=FALSE}
add_analysis_js <- paste0('Node Index:<b>',
                           1:length(tp_data_mapper$points_in_vertex),
                           '</b><br>')
network_visualization(tp_data_mapper, groups_ind = tp_data$Group, dat = tp_data[,2:4],
                      folder = "Exp_network", add_analysis_js = add_analysis_js)

```


# Example 3: Use and define different filter functions.

One object of this package is to help users to select filter functions for Mapper. This package includes 7 built-in filter functions: `filter_ref`, `filter_pca`, `filter_Linf`, `filter_gaussian`, `filter_coordinate`, `filter_dtm`, `filter_eccen`:

| Function            | Name                  | Expression                                                                                                                  |
|---------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------------|
|        `filter_ref` | Reference             | $$f(x_i;y,g) = 1âˆ’\text{median}_{y_j=g} d(x_i,x_j)$$                                                                         |
|        `filter_pca` | PCA                   | $$f(x_i) = x_i^T\phi_{(1)}$$, where $$\phi_{(1)}$$ is the eigenvector associated with the largest eigenvalue of $$cov(X)$$. |
|       `filter_Linf` | L-infinity            | $$f(x_i) = max_{j} d(x_i,x_j)$$                                                                                             |
|   `filter_gaussian` | Gaussian density      | density                                                                                                                     |
| `filter_coordinate` | Coordinate projection | projection                                                                                                                  |
|        `filter_dtm` | Distance to measure   | $$f(x_i;k) = \sqrt{\frac{1}{k}\sum_{j=2}^{k+1} d^2(x_i,x_{(j)})}$$                                                          |
|      `filter_eccen` | Eccentricity          | $$f(x_i;p) = (\frac{1}{n}\sum_{j=1}^n d^p(x_i,x_j))^{1/p}$$                                                                 |


Besides the built-in filter functions, users can also define their own standard filter functions. While `mapper.kmeans` can accept any numeric vector as a filter, the optimization function `filter_evaluate` can only accept `filter` object from standard filter functions. The return value from a standard filter function should have two attributes: `class` and `filter`. `class` should always be "filter", and `filter` contains the name of the corresponding filter function. An example of a standard filter function is:
```{r eval=FALSE}
filter_eccen = function(dist, p, ...) {

  dist <- as.matrix(dist)
  res<- rowMeans(dist^p)^(1/p)
  res <- as.matrix(res)

  attr(res, "filter") <- "Eccentricity"
  class(res) <- "filter"
  return(res)
}
```


# Example 4: Result evaluation.

# Example 5: Filter function selection with Pareto frontier.

