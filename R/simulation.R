

#' Simple graphs generation
#'
#' \code{simple_visNet} generates graphs from the provided Mapper object without
#' tooltips.
#'
#' \code{simple_visNet} generates graphs from the provided Mapper object without
#' tooltips. The colors of nodes can be more flexibly defined than in
#' \code{\link{network_visualization}} which is suitable for simulation and
#' tests. The width of edges is propotional to the percentage of overlapping
#' between connected nodes.
#'
#' Users can assign colors to nodes with three different approaches.
#'
#' * If \code{color_filter=TRUE}, the colors of nodes are determined by the
#' average filter values of samples, and \code{color_fun} will map numeric
#' values to hex color codes.
#'
#' * If \code{color_filter=FALSE} and \code{color_code=NULL}, and
#' \code{groups_ind} is provided, the colors of nodes are determined by the
#' dominated group of samples according to \code{groups_ind}, and colors are
#' automatically generated by \code{color_fun}.
#'
#' * If \code{color_filter=FALSE} and \code{color_code!=NULL}, the colors of
#' nodes are determined by the dominated group of samples, and colors are from
#' \code{color_code}.
#'
#' Note than the color method should be specified by the users by providing the
#' function with necessary arguments.
#'
#' @md
#'
#' @inheritParams network_visualization
#' @param filter A vector of filter values from filter functions
#' @param color_fun The color function that transforms numbers to hex codes.
#' @param network_name File name of the html network file.
#' @param color_filter  A logical object. \code{TRUE} if colors of nodes are to
#'   be determined by the average filter values of samples.
#' @param color_code A color code dataframe.
#' @param color_mix Boolean. If to display the color of nodes as a mixer of the
#'   colors of samples within the nodes, where colors of samples are determined
#'   by their associated groups
#' @param save_network Boolean. If save the network file. Used for the SHiny app
#'
#' @return An HTML file saved under the location given in \code{folder}. The
#'   HTML file contains the interactive graph generated based on the Mapper
#'   object.
#' @export
#'
#' @examples
#' tp_data = chicken_generator(1)
#' tp_data_mapper = mapper.kmeans(dat = tp_data[,2:4],
#'                                filter_values = tp_data$Y,
#'                                num_intervals = 10,
#'                                percent_overlap = 70)
#' simple_visNet(tp_data_mapper, filter = tp_data$Y)
#'
simple_visNet <-
  function(obj_mapper,
           filter = NULL,
           folder = getwd(),
           color_fun = color_map_Spectral,
           network_name = "network.html",
           color_filter = TRUE,
           groups_ind = NULL,
           color_code = NULL,
           color_mix = FALSE,
           save_network = TRUE) {
    require(visNetwork)
    require(RColorBrewer)

    # Remove nodes without samples
    obj_mapper = null_remover(obj_mapper)

    MapperNodes <- STA:::mapperVertices(obj_mapper, 1)
    MapperLinks <- STA:::mapperEdges(obj_mapper)

    if (color_filter) {
      if (is.null(color_fun)) {
        stop("color_fun not provided")
      }

      if (is.null(filter)) {
        warning("filter not provided, repalced by 1.")
        filter <- rep(1, max(unlist(obj_mapper$points_in_vertex)))
      }

      dir.create(file.path(folder), showWarnings = FALSE)

      avg_filter <- c()
      for (i in obj_mapper$points_in_vertex) {
        avg_filter <- c(avg_filter, mean(filter[i], na.rm = TRUE))
      }

      # Standardize to (0, 1)
      avg_filter <- (avg_filter - min(avg_filter))/(max(avg_filter) - min(avg_filter))

      nodes <-
        data.frame(
          id = 1:nrow(MapperNodes),
          value = MapperNodes$Nodesize,
          color = color_fun(avg_filter)
        )
    } else if (is.null(color_code)) {
      if (is.null(color_fun)) {
        stop("Either color_code or color_fun not provided")
      }

      if (is.null(groups_ind)) {
        stop("Samples' groups_ind not provided")
      }

      # Use dominant group
      if (!color_mix) {

        dom_grp <- c()
        for (i in obj_mapper$points_in_vertex) {
          dom_grp <-
            c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
        }
        dom_grp <- as.numeric(as.factor(dom_grp)) - 1

        nodes <-
          data.frame(
            id = 1:nrow(MapperNodes),
            value = MapperNodes$Nodesize,
            color = color_fun(dom_grp / max(dom_grp))
          )

      } else if (color_mix) {

        sample_color <- as.numeric(as.factor(groups_ind)) - 1
        sample_color <- color_fun(sample_color/max(sample_color))

        avg_color <- c()
        for (i in obj_mapper$points_in_vertex) {
          avg_color <- c(avg_color, color_mixer(sample_color[i], na.rm = TRUE))
        }

        nodes <-
          data.frame(
            id = 1:nrow(MapperNodes),
            value = MapperNodes$Nodesize,
            color = avg_color
          )

      }

    } else if (check_color_code(color_code)) {
      if (is.null(groups_ind)) {
        stop("Samples' groups_ind not provided")
      }

      # Use provided color code

      if(!color_mix) {
        dom_grp <- c()
        for (i in obj_mapper$points_in_vertex) {
          dom_grp <-
            c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
        }

        nodes <-
          data.frame(
            id = 1:nrow(MapperNodes),
            value = MapperNodes$Nodesize,
            group = dom_grp,
            color = color_map(dom_grp, color_code = color_code)
          )
      } else if (color_mix) {

        sample_color <- color_map(groups_ind, color_code = color_code)

        avg_color <- c()
        dom_grp <- c()
        for (i in obj_mapper$points_in_vertex) {
          avg_color <- c(avg_color, color_mixer(sample_color[i], na.rm = TRUE))
          dom_grp <-
            c(dom_grp, names(sort(table(groups_ind[i]), decreasing = T))[1])
        }

        nodes <-
          data.frame(
            id = 1:nrow(MapperNodes),
            value = MapperNodes$Nodesize,
            group = dom_grp,
            color = avg_color
          )

      } else {
        stop("Invalid color_mix. Should be Boolean.")
      }

    } else {
      stop("Invalid color code")
    }

    edges <-
      data.frame(from = MapperLinks$Linksource + 1,
                 to = MapperLinks$Linktarget + 1,
                 width = MapperLinks$Linkvalue/max(MapperLinks$Linkvalue) * 20)

    net_file <- visNetwork(nodes, edges, width = "100%", height = "700px") %>%
      visInteraction(tooltipDelay = 500,
                     selectConnectedEdges = FALSE) %>%
      visOptions(highlightNearest = list(
                 enabled = TRUE,
                 degree = 2,
                 hover = T) )

    if(save_network) {
      print(net_file)

      net_file %>% visSave(file = network_name, background = "white")
      save_logic = file.rename(from = network_name, to = file.path(folder, network_name))

      if (save_logic) {
        cat("The generated HTML file can be found in:\n",
            file.path(folder, network_name),
            "\n")
      } else {
        warning("Cannot save file in the target folder,
              please check the working directory.")
      }
    } else {
      return(net_file)
    }
}


#' Chicken foot simulation data generator
#'
#' \code{chicken_generator} generates chicken foot simulation data.
#'
#' \code{chicken_generator} generates chicken foot simulation data with 450 data
#' points in total. It consists of three toes and one shank. Each of the toes
#' contains 105 data points and the shank contains 135 data points.
#'
#' @param seed A scaler determining the seed to be used.
#'
#' @return A dataframe of the simulated data. The first column denotes the
#'   groups of the points and the last three columns are the coordinates of data
#'   points.
#' @export
#'
#' @examples
#' chicken_generator(1)
#'
chicken_generator <- function(seed = 1) {
  library(MASS)
  set.seed(seed)

  x_1 <- 0:20
  y_1 <- 2 * x_1
  d1 <- cbind(1, x_1, y_1)

  x_2 <- -x_1
  y_2 <- y_1
  d2 <- cbind(2, x_2, y_2)

  x_3 <- 0
  y_3 <- 0:(-20)
  d3 <- cbind(4, x_3, y_3)

  x_4 <- 0
  y_4 <- 0:20 * 2
  d4 <- cbind(3, x_4, y_4)

  d <- rbind(d1, d2, d3, d4)

  d <- cbind(d, 0)

  dd <- NULL
  for (i in 1:nrow(d)) {
    tmp <- mvrnorm(n = 5,
                   mu = as.vector(d[i, 2:4]),
                   Sigma = 0.7 *
                     diag(3))
    tmp <- cbind(d[i, 1], tmp)
    dd <- rbind(dd, (tmp))
  }

  dd <-
    rbind(dd, cbind(4, mvrnorm(
      n = 30,
      mu = c(0,-0.5, 0),
      Sigma = diag(c(16, 8, 1))
    )))

  dd <- as.data.frame(dd)
  colnames(dd) <- c("Group", "X", "Y", "Z")

  dd$Y <- dd$Y - min(dd$Y)
  dd$X <- dd$X - min(dd$X)
  dd$Z <- dd$Z - min(dd$Z)

  dd$X <- dd$X / max(dd$X + 0.01)
  dd$Y <- dd$Y / max(dd$Y + 0.01)
  dd$Z <- dd$Z / max(dd$Z + 0.01) / 5

  dd$Group[dd$Group == 1] <- "Toe 1"
  dd$Group[dd$Group == 2] <- "Toe 2"
  dd$Group[dd$Group == 3] <- "Toe 3"
  dd$Group[dd$Group == 4] <- "Shank"

  return(dd)
}
